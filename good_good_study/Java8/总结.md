# 总结

## 一：数据结构篇

### 线性表：

线性表是一种线性结构，它是由零个或多个数据元素构成的**有限序列**。线性表的特征是在一个序列中，除了头尾元素，每个元素都有且只有一个直接前驱，有且只有一个直接后继，而序列头元素没有直接前驱，序列尾元素没有直接后继。

数据结构中常见的线性结构有数组、单链表、双链表、循环链表等。线性表中的元素为某种**相同**的抽象数据类型。可以是C语言的内置类型或结构体，也可以是C++自定义类型

### 数组

数组在实际的物理内存上也是连续存储的，数组有**上界**和**下界**。C语言中定义一个数组：
![](../image/d126accegy1g1rnnibbq2j20l307i3yj.jpg)

数组下标是从0开始的，a[0]对应第一个元素。其中，a[0]称为数组a的下界，a[6]称为数组a的上届。超过这个范围的下标使用数组，将造成**数组越界错误**。
数组的特点是：**数据连续，支持快速随机访问。**
数组分为固定数组与动态数组。其中固定数组的大小必须在编译时就能够确认，动态数组允许在运行时申请数组内存。复杂点的数组是多维数组，多维数组实际上也是通过一维数组来实现的。

### 单向链表

单向链表是链表的一种。链表由节点所构成，节点内含一个指向下一个节点的指针，节点依次链接成为链表。因此，链表这种数据结构通常在物理内存上是不连续的。链表的通常含有一个头节点，头节点不存放实际的值，它含有一个指针，指向存放元素的第一个节点。

```java
class Node():    
 单链表中的节点应该具有两个属性：val 和 next。    val 是当前节点的值，    next 是指向下一个节点的指针/引用。     `

` def __init__(self, value):   # 存放元素数据  self.val = value   # next是下一个节点的标识  self.next = None`
```



#### 设计链表的实现

您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

- get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。

- addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。

- addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。

- addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。

- deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点

  ![](../image/d126accegy1g1rnv3t6cdj20l30hmmxk.jpg)

  

#### 链表与顺序表的对比

链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。

链表与顺序表的各种操作复杂度如下所示：

| 操作            | 链表 | 顺序表 |
| --------------- | ---- | ------ |
| 访问元素        | O(n) | O(1)   |
| 在头部插入/删除 | O(1) | O(n)   |
| 在尾部插入/删除 | O(n) | O(1)   |
| 在中间插入/删除 | O(n) | O(n)   |



## 二：算法篇

## 三：java代码篇

### 一：Java8

#### 流（Stream）

流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。思路变成了把这样的流变成那样的流（就像写数据库查询语句时的那种思路），而不是一次只处理一个项目。另一个好处是，Java 8可以透明地把输入的不相关部分拿到几个CPU内核上去分别执行你的 Stream操作流水线——这是几乎免费的并行，用不着去费劲搞Thread了。

#### 操作

+ filter——接受Lambda，从流中排除某些元素。在本例中，通过传递lambda d -> d.getCalories() > 300，选择出热量超过300卡路里的菜肴。
+ map——接受一个Lambda，将元素转换成其他形式或提取信息。在本例中，通过传递方法引用Dish::getName，相当于Lambda d -> d.getName()，提取了每道菜的菜名。
+ limit——截断流，使其元素不超过给定数量。

collect——将流转换为其他形式。在本例中，流被转换为一个列表。它看起来有点儿像变魔术，我们在第6章中会详细解释collect的工作原理。现在，你可以把collect看作能够接受各种方案作为参数，并将流中的元素累积成为一个汇总结果的操作。这里的toList()就是将流转换为列表的方案。

+  一个数据源（如集合）来执行一个查询；
+  一个中间操作链，形成一条流的流水线；
+  一个终端操作，执行流水线，并能生成结果。

##### 中间操作

![image-20221115210428681](..\image\image-20221115210428681.png)

##### 终端操作

![image-20221115210729770](../image/image-20221115210729770.png)

##### 用谓词筛选

Streams接口支持filter方法。该操作会接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流

![image-20221115211554719](../image/image-20221115211554719.png)



##### 筛选和切片

###### 筛选各异的元素

流还支持一个叫作distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。

```java
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); 
numbers.stream()  .filter(i -> i % 2 == 0) .distinct().forEach(System.out::println);
```

![image-20221115211524638](../image/image-20221115211524638.png)

###### 截短流

流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。(请注意limit也可以用在无序流上，比如源是一个Set。这种情况下，limit的结果不会以任何顺序排列。)

```java
List<Dish> dishes = menu.stream() 
 .filter(d -> d.getCalories() > 300) 
 .limit(3) 
 .collect(toList());
```

![image-20221115211732430](../image/image-20221115211732430.png)

###### 跳过元素

流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。请注意，limit(n)和skip(n)是互补的！

```java
List<Dish> dishes = menu.stream() 
 .filter(d -> d.getCalories() > 300) 
 .skip(2) 
 .collect(toList());
```

![image-20221115211945339](../image/image-20221115211945339.png)

##### 映射

###### 对流中每一个元素应用函数

流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）

```java
List<String> dishNames = menu.stream() 
 .map(Dish::getName) 
 .collect(toList());
```

eg：现在让我们回到提取菜名的例子。如果你要找出每道菜的名称有多长，怎么做？你可以像下面这样，再链接上一个map

```java
List<Integer> dishNameLengths = menu.stream() 
 .map(Dish::getName) 
 .map(String::length) 
 .collect(toList());
```

###### 流的扁平化

使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流

```java
List<String> uniqueCharacters = words.stream() 
 .map(w -> w.split("")) 
 .flatMap(Arrays::stream) 
 .distinct() 
 .collect(Collectors.toList());
```

![image-20221115213144294](../image/image-20221115213144294.png)

![image-20221115213209365](../image/image-20221115213209365.png)

一言以蔽之，flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。

###### 测验 映射

```java
(1) 给定一个数字列表，如何返回一个由每个数的平方构成的列表呢？例如，给定[1, 2, 3, 4, 5]，应该返回[1, 4, 9, 16, 25]。

答案：你可以利用map方法的Lambda，接受一个数字，并返回该数字平方的Lambda来解决这个问题。

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); 

List<Integer> squares = numbers.stream() .map(n -> n \* n) .collect(toList()); 

(2) 给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应
该返回[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]。为简单起见，你可以用有两个元素的数组来代表数对。 

答案：你可以使用两个map来迭代这两个列表，并生成数对。但这样会返回一个Stream- <Stream<Integer[]>>。你需要让生成的流扁平化，以得到一个Stream<Integer[]>。这正是flatMap所做的：

List<Integer> numbers1 = Arrays.asList(1, 2, 3); 

List<Integer> numbers2 = Arrays.asList(3, 4); 

List<int[]> pairs = numbers1.stream() .flatMap(i -> numbers2.stream().map(j -> new int[]{i, j})).collect(toList()); 

(3) 如何扩展前一个例子，只返回总和能被3整除的数对呢？例如(2, 4)和(3, 3)是可以的。

答案：你在前面看到了，filter可以配合谓词使用来筛选流中的元素。因为在flatMap操作后，你有了一个代表数对的int[]流，所以你只需要一个谓词来检查总和是否能被3整除就可以了：

List<Integer> numbers1 = Arrays.asList(1, 2, 3); 

List<Integer> numbers2 = Arrays.asList(3, 4); 

List<int[]> pairs =  numbers1.stream() 

 .flatMap(i -> numbers2.stream() 

 .filter(j -> (i + j) % 3 == 0) 

 .map(j -> new int[]{i, j}) 

 ) 
 .collect(toList()); 

其结果是[(2, 4), (3, 3)]。

```

##### 查找和匹配

另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具

###### 检查谓词是否至少匹配一个元素

anyMatch方法可以回答“流中是否有一个元素能匹配给定的谓词”。比如，你可以用它来看看菜单里面是否有素食可选择：

```java
if(menu.stream().anyMatch(Dish::isVegetarian)){ 
 System.out.println("The menu is (somewhat) vegetarian friendly!!"); 
} 
```

anyMatch方法返回一个boolean，因此是一个终端操作。

###### 检查谓词是否匹配所有元素

allMatch方法的工作原理和anyMatch类似，但它会看看流中的元素是否都能匹配给定的谓词

```java
boolean isHealthy = menu.stream() .allMatch(d -> d.getCalories() < 1000);
```

###### noneMatch

和allMatch相对的是noneMatch。它可以确保流中没有任何元素与给定的谓词匹配

```java
boolean isHealthy = menu.stream() .noneMatch(d -> d.getCalories() >= 1000);
```

anyMatch、allMatch和noneMatch这三个操作都用到了我们所谓的短路，这就是大家熟悉的Java中&&和||运算符短路在流中的版本

##### 短路求值

有些操作不需要处理整个流就能得到结果。例如，假设你需要对一个用and连起来的大布尔表达式求值。不管表达式有多长，你只需找到一个表达式为false，就可以推断整个表达式将返回false，所以用不着计算整个表达式。这就是**短路**。对于流而言，某些操作（例如allMatch、anyMatch、noneMatch、findFirst和findAny）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样，limit也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流。

###### 查找元素

findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用

```java
Optional<Dish> dish =  menu.stream() .filter(Dish::isVegetarian) .findAny(); 
```

流水线将在后台进行优化使其只需走一遍，并在利用短路找到结果时立即结束

###### 查找第一个元素

有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，你可能想要找到第一个元素。为此有一个findFirst方法，它的工作方式类似于findany。

```java
List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5); 
Optional<Integer> firstSquareDivisibleByThree = someNumbers.stream() .map(x -> x * x) 
 .filter(x -> x % 3 == 0) 
 .findFirst(); // 9
```

###### 何时使用**findFirst**和**findAny**?

你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。

##### 归约

###### 元素求和

```java
int sum = numbers.stream().reduce(0, (a, b) -> a + b); 
```

无初始值 reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：

```java
Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));
```

![image-20221115215645565](../image/image-20221115215645565.png)

##### 数值流

###### 原始类型流特化

Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和 LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。每 个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max。 此外还有在必要时再把它们转换回对象流的方法。要记住的是，这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和Integer之间的效率差异。

映射到数值流

将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前 面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream

```java
int calories = menu.stream() .mapToInt(Dish::getCalories) .sum();
```

##### flatMap

使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容



![image-20221118135214030](../image/image-20221118135214030.png)

例如：给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应 该返回[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]。为简单起见，你可以用有两个元素的数组来代 表数对。

答：使用两个map来迭代这两个列表，并生成数对。但这样会返回一个Stream- <Stream<Integer[]>>。你需要让生成的流扁平化，以得到一个Stream<Integer[]>。这正是flatMap所做的： 

```java
List<Integer> numbers1 = Arrays.asList(1, 2, 3); 
List<Integer> numbers2 = Arrays.asList(3, 4); 
List<int[]> pairs = 
 numbers1.stream() 
 .flatMap(i -> numbers2.stream() 
 .map(j -> new int[]{i, j}))
 .collect(toList()); 
```





#### 小结

+  流是“从支持数据处理操作的源生成的一系列元素”。
+  流利用内部迭代：迭代通过filter、map、sorted等操作被抽象掉了。
+  流操作有两类：**中间操作**和**终端操作**。
+  filter和map等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果。
+  forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果。
+  流中的元素是按需计算的。

### 二：杂记

#### 注解篇

##### @NotNull&&@NotBlank&&@NotEmpty

- @**NotNull**适用于基本数据类型(**Integer**，**Long**，**Double**等等)，当 @NotNull 注解被使用在 String 类型的数据上，则表示该数据不能为 Null（但是可以为 Empty）
- @**NotBlank**适用于 **String** 类型的数据上，加了@NotBlank 注解的参数不能为 Null 且 **trim()** 之后 **size > 0**
- @**NotEmpty**适用于 String、**Collection**集合、Map、数组等等，加了@NotEmpty 注解的参数不能为 Null 或者 长度为 0

## 四：工具篇

### Git 操作

- git init   初始化；

- git branch git查看分支**名称**；

- git remote add origin git 远程代码仓库地址 ， 与远程git代码仓库建立**连接**，

- git fetch origin 分支名称 （更新分支最新状态）**切换分支拉取代码** ；

- git checkout -b 分支名称 默认拉取的分支为master主分支，需要用命令来对**分支进行切换**；

- git pull origin 分支名称；**拉取**代码与线下的git代码合并；

-  git push -u origin dev-2.0.1 最后合并完后将代码**push**到git上；

- **生成SSH** ssh-keygen -t rsa -C '402542336@qq.com' -f ~/.ssh/gitee_id_rsa；

- git config credential.helper store 执行完 第一次要输入账号密码，以后就不用了。不加参数： --**global** 只对这个仓库生效，并非全局设置 。

## 五: Linux

### 常用命令

- ifconfig -a  **查看ip地址**

### 安装mysql

wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 下载mysql包

安装mysql包`

```sql
yum -y install mysql57-community-release-el7-10.noarch.rpm 
```

![](../image/image-20221114183723950.png)

```
yum -y install mysql-community-server 安装mysql 
```

![image-20221114183858141](../image/image-20221114183858141.png)

遇见的错误

```
*yum -y install mysql-community-server --nogpgcheck*  需要禁掉GPG验证检查
```

![image-20221114190526864](../image/image-20221114190526864.png)

```sql
service mysqld status查看mysql运行状态
```

![image-20221114185953866](../image/image-20221114185953866.png)

```sql
grep ‘password’ /var/log/mysqld.log 查看mysql密码
```

![image-20221114190641912](../image/image-20221114190641912.png)

```sql
mysql -u root -p 进入mysql
```

![image-20221114190616837](../image/image-20221114190616837.png)

```js
stop mysqld.service 关闭服务
```

![](../image/image-20221114191136923.png)

```js
vim /etc/my.cnf
```

![image-20221114191331068](../image/image-20221114191331068.png)

```js
输入i  加入skip-grant-tables  然后esc  ：wq保存退出
```

![image-20221114191605195](../image/image-20221114191605195.png)

```
service mysqld start 重启mysql 服务
```

![image-20221114191711847](../image/image-20221114191711847.png)

```sql
show databases；
```

![image-20221114191918211](../image/image-20221114191918211.png)

3.安装jdk

```sql
yum install -y java-1.8.0-openjdk.x86_64 下载jdk 
```

![image-20221115112531723](../image/image-20221115112531723.png)

```sql
java -version  查看版本
```

![image-20221115112632270](../image/image-20221115112632270.png)

2.安装nacos

下载nacos

```sql
[wget](https://so.csdn.net/so/search?q=wget&spm=1001.2101.3001.7020) https://github.com/alibaba/nacos/releases/download/1.2.0/nacos-server-1.2.0.tar.gz
```

![image-20221115124650242](../image/image-20221115124650242.png)

tar -xvf nacos-server-1.2.0.tar.gz 解压nacos

![image-20221115124745330](../image/image-20221115124745330.png)

## 六：mysql

### sql语句

#### 修改字段名

```
mysql修改字段名：
ALTER  TABLE 表名 CHANGE [column] 旧字段名 新字段名 新数据类型; 
```

#### 修改表名

```sql
在mysql中可以使用【alter table 旧表名 rename 新表名;】语句修改表名，如
【mysql> alter table user rename user2 default null comment '';】
```

#### 修改某一列的类型

```sql
alter table 表名 modify 列名 类型;
mysql> alter table type modify type_name varchar(100) default null comment '';
```

#### 增加一列

```sql
alter table 表名 add 列名 类型;
mysql> alter table type add age int(11) default null comment '';
```

#### .删除一列

```sql
用法：alter table type drop 列名;
mysql> alter table type drop age default null comment '';
```

ddddd